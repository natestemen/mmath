% ***********************************************
\chapter{Circuit Compilers}\label{ch:circuit-compilers}
% ***********************************************

We can now return to the issue of compilers.
It should now be clear that the level of abstraction we work at when designing quantum algorithms is much higher than the capabilities of our current, and likely future hardware.
Hence quantum compilers are needed for two steps.
\begin{figure}[h]
    \centering
    \tikzset{
        frame/.style={
                draw,
                text width=6em,
                text centered,
                minimum height=4em,
                drop shadow,
                fill=orange!40,
                rounded corners,
            },
    }
    \begin{tikzpicture}[font=\sffamily, very thick, node distance=4cm]
        \node[align=center] (qa) {Quantum \\ Algorithm};
        % \node[frame, right of=qa] (compiler) {Compiler};
        \node[frame, right of=qa] (ir) {};%Intermediate \\ Representation};
        \node[align=center, above right=.5cm and 1cm of ir] (ha) {Hardware A};
        \node[align=center, below=.5cm of ha] (hb) {Hardware B};
        \node[align=center, below=.1cm of hb] (hdots) {\vdots};

        % \node[align=center, right of=compiler] (ml) {Hardware A};

        \draw[-stealth] (qa) -- (ir);
        \draw[-stealth] (ir) -- (ha);
        \draw[-stealth] (ir) -- (hb);
        % \draw[-stealth] (ir) -- (hdots);

        \node[very thick, draw=orange!20, fit=(ir), inner sep=3mm, label=above:{Quantum Compiler}, rounded corners](qcompiler) {};
    \end{tikzpicture}
    \caption{Action of Quantum Compiler}\label{fig:quantumcompiler}
\end{figure}

\dots Thus when compiling circuits, we need to minimize the number of \SWAP{} gates we must add since we saw in~\cref{eq:cnotswap} that each \SWAP{} takes 3 \CNOT{} gates.

\paragraph{Compiling the Toffoli Gate}
Since most hardware are not capable of 3-qubit operations we must decompose the Toffoli, or \CCNOT{} gate into something more manageable.
This is typically done using \CNOT{}'s, Hadamard's ($H$), and $\pi/8$ ($T$) gates~\cite{nielsenchuang}.
\begin{equation}
    \begin{quantikz}[column sep=.25cm]
        & \ctrl{1} & \midstick[3,brackets=none]{$=$} \qw & \qw      & \qw      & \qw              & \ctrl{2} & \qw      & \qw      & \qw              & \ctrl{2} & \qw      & \ctrl{1} & \gate{T}         & \ctrl{1} & \qw \\
        & \ctrl{1} & \qw                                 & \qw      & \ctrl{1} & \qw              & \qw      & \qw      & \ctrl{1} & \qw              & \qw      & \gate{T} & \targ{}  & \gate{T^\dagger} & \targ{}  & \qw \\
        & \targ{}  & \qw                                 & \gate{H} & \targ{}  & \gate{T^\dagger} & \targ{}  & \gate{T} & \targ{}  & \gate{T^\dagger} & \targ{}  & \gate{T} & \gate{H} & \qw              & \qw      & \qw
    \end{quantikz}
\end{equation}
This is an important decomposition as the \CCNOT{} gate appears in the modular exponentiation problem which is a core part of Shor's algorithm~\cite{shor-encryption}.
Hence if there are smaller decompositions than shown above that would be ideal as \emph{one} \CCNOT{} gate becomes 14!
\citeauthor{universal-cnot-u2} show a more compact decomposition of \CCNOT{} using only 3 \CNOT{} gates if the phase of one of the qubits is allowed to change~\cite{universal-cnot-u2}.
Let $G = R_Y(\frac{\pi}{4})$ in the following circuit. % following https://arxiv.org/pdf/quant-ph/9705009.pdf rather than original paper
\begin{equation}
    \begin{quantikz}%[column sep=.25cm]
        & \ctrl{1} & \midstick[3,brackets=none]{$\approx$} \qw & \qw                        & \qw      & \qw                        & \ctrl{2} & \qw                       & \qw      & \qw                       & \qw \\
        & \ctrl{1} & \qw                                       & \qw                        & \ctrl{1} & \qw                        & \qw      & \qw                       & \ctrl{1} & \qw                       & \qw \\
        & \targ{}  & \qw                                       & \gate{G^\dagger} & \targ{}  & \gate{G^\dagger} & \targ{}  & \gate{G} & \targ{}  & \gate{G} & \qw
    \end{quantikz}
\end{equation}
However the question ended in~\citeyear{toff3cnot} when it was shown that a true equality preserving decomposition of the \CCNOT{} gate requires a minimum of 6 \CNOT{} gates~\cite{toff3cnot}.\footnote{This result shows that a minimum of 6 \CNOT{} gates must be used, \textbf{if} they are being used. Other decompositions not using \CNOT{} gates might still be more compact.}

\section{Strong and Weak Compilation}


One of the benefits of the modular compiler structure seen in~\cref{fig:compends} is that once the optimizer is made, we can write a backend to go to real hardware, \textbf{and} write another backend to send the code to classical hardware.
This in effect provides an optimized quantum simulator.

\section{Compiling on a ring}

In this section we will see an example that will take us through some of the many difficulties one might face while attempting to come up with a general purpose algorithm/method for compiling quantum circuits.
This example is drawn from~\cite{ring-compilation} with modifications.

To begin suppose we'd like to run the quantum circuit shown in~\cref{fig:presquish}.
\begin{figure}[ht]
    \centering
    \begin{quantikz}%[row sep=.2cm]
        & \targ{}   & \qw      & \gate{X} & \qw      & \ctrl{1} & \qw      & \qw      & \qw      & \qw       & \targ{}   & \qw       & \qw \\
        & \qw       & \ctrl{2} & \qw      & \ctrl{1} & \targ{}  & \ctrl{1} & \qw      & \gate{H} & \targ{}   & \ctrl{-1} & \qw       & \qw \\
        & \ctrl{-2} & \qw      & \qw      & \targ{}  & \qw      & \targ{}  & \gate{H} & \qw      & \ctrl{-1} & \qw       & \targ{}   & \qw \\
        & \qw       & \targ{}  & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw       & \qw       & \ctrl{-1} & \qw
    \end{quantikz}
    \caption{Circuit to be compiled}\label{fig:presquish}
\end{figure}
The first step we can take is to compress the diagram into a fewer number of layers.
To do this we group operations on non-overlapping qubits since they can be performed at the same time.
This is vital as decoherence times (\cref{sec:Ttimes}) are so short.
This ``compressed'' version of the circuit is seen in~\cref{fig:precomp}.
\begin{figure}[ht]
    \centering
    \begin{quantikz}
        & \targ{}   & \qw \slice{} & \gate{X} \slice{} & \ctrl{1} \slice{} & \qw \slice{} & \qw \slice{} & \qw \slice{} & \targ{}   & \qw \\
        & \qw       & \ctrl{2}     & \ctrl{1}          & \targ{}           & \ctrl{1} \gategroup[2,steps=3,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{}    & \gate{H}     & \targ{}      & \ctrl{-1} & \qw \\
        & \ctrl{-2} & \qw          & \targ{}           & \qw               & \targ{}      & \gate{H}     & \ctrl{-1}    & \targ{}   & \qw \\
        & \qw       & \targ{}      & \qw               & \qw               & \qw          & \qw          & \qw          & \ctrl{-1} & \qw
    \end{quantikz}
    \caption{Circuit after compression}\label{fig:precomp}
\end{figure}

We can now apply a ``device independent optimization'' or ``peephole optimization'' using the fact that $\CNOT^2_1\cdot (H \otimes H)\cdot\CNOT^1_2 = H \otimes H$. %TODO add something in chapter 1 about the diff between pre and post device optimizations so this can relate
This minor optimization, and many others can be found in~\cite{peephole}.
Hence we can drop the two \CNOT{} gates in the blue box to obtain the figure seen in~\cref{fig:predevice}.
\begin{figure}[ht]
    \centering
    \begin{quantikz}
        q_1 & \targ{}   & \qw \slice{} & \gate{X} \slice{} & \ctrl{1} \slice{} & \qw \slice{} & \targ{}   & \qw \\
        q_2 & \qw       & \ctrl{2}     & \ctrl{1}          & \targ{}           & \gate{H}     & \ctrl{-1} & \qw \\
        q_3 & \ctrl{-2} & \qw          & \targ{}           & \qw               & \gate{H}     & \targ{}   & \qw \\
        q_4 & \qw       & \targ{}      & \qw               & \qw               & \qw          & \ctrl{-1} & \qw
    \end{quantikz}
    \caption{Circuit after peephole optimization}\label{fig:predevice}
\end{figure}

To continue with the problem we must now choose hardware we would like to run this circuit on.
As the section title suggest, we will be choosing a qubit network topology of a ring.
\begin{figure}[ht] % TODO make labels Q_i instead of i
    \centering
    \includestandalone[width=0.4\textwidth]{tikz/ring}
    \caption{Ring Topology}\label{fig:ring}
\end{figure}
The first problem we need to tackle is placing the qubits from the circuit onto the ring.
The first slice of the circuit contains \CNOT{}s connecting $q_1 \leftrightarrow q_3$ and $q_2 \leftrightarrow q_4$ so placing them together to prevent additional \SWAP{}s from being added is the first task.
There are many configurations to satisfy this, but only one\footnote{Modulo ring rotations/reflections.} that satisfy the requirements that no \SWAP{} gates are added in the second slice as well!
That mapping is
\begin{align}
    q_1 \to 1 &  & q_2 \to 3 &  & q_3 \to 2 &  & q_4 \to 4.
\end{align}
Hence the first two slices of the circuit can be computed without any additional \SWAP{} gates being added.

Executing the gates in slice 3 however will require a \SWAP{} as qubits $q_1$ and $q_2$ are no longer adjacent.
To make these qubits adjacent we can either swap qubits $q_1$ and $q_3$ or $q_2$ and $q_3$.
Looking ahead to slice 5 we see we need adjacency of $q_1 \leftrightarrow q_2$ and $q_3 \leftrightarrow q_4$.
Swapping $q_1$ and $q_3$ would mean two additional \SWAP{} gates before slice 5, but swapping $q_2$ and $q_3$ leaves the qubits in their desired positions for slice 5.
Hence our compiled circuit in it's final form:
\begin{figure}[ht]
    \centering
    \begin{quantikz}
        & \targ{}   & \gate{X}  & \qw           & \ctrl{1} & \qw      & \qw           & \targ{}   & \qw \\
        & \ctrl{-1} & \targ{}   & \gate[swap]{} & \targ{}  & \gate{H} & \gate[swap]{} & \ctrl{-1} & \qw \\
        & \ctrl{1}  & \ctrl{-1} &               & \qw      & \gate{H} &               & \targ{}   & \qw \\
        & \targ{}   & \qw       & \qw           & \qw      & \qw      & \qw           & \ctrl{-1} & \qw
    \end{quantikz}
    \caption{Compiled Circuit}\label{fig:compcirc}
\end{figure}

If the quantum chip has the further restriction that it's network topology is a directed graph and all the edges point clockwise, we can no longer use the typical \SWAP{} decomposition we are used to as in~\cref{eq:cnotswap}.
Instead we must use
\begin{equation}
    \begin{quantikz}
        & \targ{}   & \midstick[2,brackets=none]{$=$} \qw & \gate{H} & \ctrl{1} & \gate{H} & \qw \\
        & \ctrl{-1} & \qw                                 & \gate{H} & \targ{}  & \gate{H} & \qw
    \end{quantikz}
\end{equation}
in~\cref{eq:cnotswap} to decompose \SWAP{} using only \CNOT{} gates that go in one direction.
\begin{equation}
    \begin{quantikz}
        & \gate[swap]{} & \midstick[2,brackets=none]{$=$} \qw & \targ{}   & \gate{H} & \targ{}   & \gate{H} & \targ{}   & \qw \\
        &               & \qw                                 & \ctrl{-1} & \gate{H} & \ctrl{-1} & \gate{H} & \ctrl{-1} & \qw
    \end{quantikz}
\end{equation}
With this addition the compiled circuit begins to grow very quickly (\cref{fig:dirringcomp})
\begin{figure}[ht]
    \centering
    \begin{quantikz}[column sep=.1cm]
        & \gate{H} & \ctrl{1} & \gate{H} & \gate{X} & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \ctrl{1} & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \gate{H} & \ctrl{1} & \gate{H} & \qw \\
        & \gate{H} & \targ{}  & \qw      & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \targ{}  & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \targ{}  & \gate{H} & \qw \\
        & \qw      & \ctrl{1} & \gate{H} & \targ{}  & \gate{H} & \targ{}  & \gate{H} & \targ{}  & \gate{H} & \targ{}  & \qw      & \gate{H} & \targ{}  & \gate{H} & \targ{}  & \gate{H} & \targ{}  & \gate{H} & \ctrl{1} & \gate{H} & \qw \\
        & \qw      & \targ{}  & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \qw      & \gate{H} & \targ{}  & \gate{H} & \qw
    \end{quantikz}
    \caption{Compiled Circuit on Directed Ring}\label{fig:dirringcomp}
\end{figure}

While this was a relatively simple example of some of the tasks a circuit compiler must complete, it did not begin to touch on the problem of gate decomposition.
In the above example all gates applied were ones our made up ring computer could natively work with.


\section{Methods}

It's important to note that quantum circuit compilers exist and in many of the references that follow the authors' proposed compilation methods are benchmarked against the most prevalent compiler which happens to be IBM's Qiskit~\cite{qiskit}.

\paragraph{QAOA}
Compilers have also been built to attack specific problems such as the \ac{QAOA}~\cite{qaoa} where particular gates can be swapped horizontally in circuit diagrams due to their commutative nature.
Focusing in this particular problem, the authors in~\cite{qaoa-compiler} have been able to reduce the gate count by 23\% and circuit depth by 53\% on average.
In the future we might hope to build these problem specific compilers into a more general purpose one that can diagnose and understand when to use problem specific compilers on demand.

\paragraph{VQE}
Another hybrid quantum-classical algorithm that has seem much attention is that of the \ac{VQE}~\cite{vqe,vqe2}.
This algorithm is used in quantum chemistry to calculate the ground state of a molecular Hamiltonian using a parametrized quantum circuit as a cost function, and the classical compute nodes as an optimizer.
\Eg{} let $\boldsymbol{\theta} \in \R^n$ be a vector of numbers that our circuit $U$ depends on, \ie{} $U: \R^n \to \U{2^m}$ for some number of qubits $m$.
\begin{figure}[ht] % TODO label positioning fucked
    \centering
    \includestandalone[width=0.8\textwidth]{tikz/vqe}
    \caption{\acs{VQE} Schematic}\label{fig:vqe}
\end{figure}
A compiler specific to this problem has been created, and generalized to further quantum-classical algorithms in~\cite{vqe-compiler} and the authors have leveraged much of the existing infrastructure brought forth by the LLVM project discussed in~\cref{sec:llvm}.
This allows the classical optimizations to be handled by the robust LLVM system, while using new circuit compilation techniques on the variational circuit.


\section{Quantum Stack}

In this section we will give an overview of the related technologies to quantum circuit compilation and try and explain how they fit together to form a quantum full stack.

\texttt{qcor}~\cite{qcor}.