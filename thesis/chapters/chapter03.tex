%************************************************
\chapter{Quantum Hardware}\label{ch:hardware}
%************************************************

The goal of this chapter is twofold.
First we introduce the most common constraints seen in modern quantum hardware, as well as other common tools used to measure the effectiveness and efficacy of a given quantum computer.
Second we will introduce the mathematical formalism needed in order to formulate the problems related to quantum circuit compilation we will see in~\cref{ch:circuit-compilers}.
We will not, however, attempt to give an introduction to the physical implementations of quantum hardware and instead refer the reader to~\cite{nielsenchuang} for a more comprehensive introduction.

\section{Requirements}
As we saw in~\cref{sec:history} the first realization of a qubit happened in~\citeyear{firstqubit}.
A year later David DiVincenzo proposed 5 requirements as being necessary to make an effective quantum information processing device~\cite{divincenzo}.
His proposed requirement are summarized here.
\begin{requirements}
    \item A scalable physical system with well characterized qubits.\label{req:scalable}
    \item The ability to initialize the state of the qubits to a simple fiducial state, such as $\ket{0}^{\!\otimes n}$.\label{req:initialize}
    \item Long decoherence times, much longer than the gate operation time.\label{req:Ttimes}
    \item A universal set of quantum gates.\label{req:universal}
    \item A qubit specific measurement capability.\label{req:measure}
\end{requirements}
While all of these requirements are still under active research,~\cref{req:initialize,req:universal,req:measure} are completed for \ac{NISQ} devices, while~\cref{req:Ttimes,req:scalable} keep us in the \ac{NISQ}-era.
However, even if all of these problems were solved completely, there is still many things that can go wrong.
Just because your qubits scale doesn't mean you have an unlimited amount that you can use for memory an algorithm might require.
Just because there is a long decoherence time doesn't mean a qubit can't error in some other way.
Just because you have a universal gate set doesn't mean you know how to efficiently decompose a gate from the algorithm you are trying to run.

As you can see, these five requirements provide us with the backbone upon which we can build further, but do not guarantee optimal quantum computations.
It is some of these secondary question we wish to understand more deeply to make quantum computers more useful once the bedrock has been established.

\section{Quantum Chips}

Intuitively a quantum chip is a collection of qubits along with the capability to perform operations on subsets of the qubits.
This can be formalized using the notion of a hypergraph as follows.
\begin{definition}
    A \emph{quantum chip} is a 2-tuple $(G, H)$ where $G$ is a gateset, and $H$ is a hypergraph $H = (Q, E)$ with the vertices $Q$ representing qubits, and edges $E$ being a subset of the powerset $\mathcal{P}(Q) \setminus \qty{\emptyset}$ representing connections between qubits where quantum gates of the correct arity can be applied.
\end{definition}
In practice it is often the case that that a quantum chip has the more standard structure of a graph and there are no native $k$-qubit gates for $k > 2$.
This can partially be attributed to the fact that we do not need 3-qubit gates for universal computation~\cite{universal-cnot-u2}, but also due to the experimental difficulty in implementing such capabilities.

As an example take the the topology of IBM's \texttt{ibmq\_jakarta} shown in~\cref{fig:ibm-jakarta}~\cite{ibmq}.
Node/qubit ``3'' being connected to ``1'' means that we can apply a 2-qubit unitary targeting both of those qubits, however the hardware does not support native 2-qubit gates between qubits ``2'' and ``6''.
\begin{figure}[ht]
    \centering
    \includestandalone[width=0.4\textwidth]{tikz/jakarta}
    \caption{IBMQ Jakarta Architecture}\label{fig:ibm-jakarta}
\end{figure}

We can now define the main problem of quantum circuit compilation: that of the qubit mapping problem.\footnote{This sometimes also goes by the name of the qubit routing problem, or qubit scheduling problem although sometimes these mean slightly different things.}
If we have both a quantum circuit $C \in G^*$ and a quantum computer with chip $(H, (Q, E))$, can the computer perform our circuit? % TODO better notation pls
In the case when the number of qubits required in $C$ is greater than $\abs{Q}$, the answer is no.\footnote{There are however specific cases when this \emph{is} possible. If the algorithm only required $n < \abs{Q}$ qubits to be entangled at once, there are clever scheduling tactics one can employ to implement such an algorithm. There are also ``quantum autoencoders'' which attempt to implement compressed versions of circuits on smaller numbers of qubits~\cite{autoencode}.}
On the other hand when the number of qubits required for $C$ is fewer than the number we have access to $\abs{Q}$, then the answer is yes, provided
\begin{enumerate}
    \item $H$ is a universal gate set, and
    \item $(Q, E)$ is connected.\footnote{That is for any two vertices, there is a path between them.}
\end{enumerate}
Despite formulating the key problem we'd like to understand in this document, there are many contributing factors that effect solutions to this problem
For that reason we need to not just understand a theoretical model of quantum hardware, but some of the implementation details as well.

\subsection{Hardware Specifications}

Here we will briefly cover the most important topics discussed in quantum circuit compilation when it comes to optimizations on \ac{NISQ}-era hardware.

\subsubsection{Relaxation and Dephasing Times}\label{sec:Ttimes}

As qubits are two-state systems, they are often implemented experimentally using some physical system (\eg{} an atom) that has a ground state, and an excited state.
Excited states often have a tendency to ``decay'' into ground states, especially so when interacting with the environment.
Hence we define the \textbf{relaxation time}\footnote{This value also goes by the following names: coherence time, amplitude damping, longitudinal coherence time, spin lattice time, and spontaneous emission time.} $T_1$ as the lifetime for the state $\ket{1}$ decaying into $\ket{0}$.
This value can be experimentally found using the following methodology.
\begin{enumerate}
    \item Prepare the state $\ket{0}$
    \item Apply a Pauli $X$ gate to obtain $\ket{1}$
    \item Wait some time $t$ (during this time the qubit may decay into $\ket{0}$)
    \item Measure the qubit
\end{enumerate}
Each time we measure the qubit in the ground state we record the amount of time $t$ we waited.
This process is then modelled with an exponential decay of the form $\e^{-t/T_1}$.

The second important factor we need to understand is the \textbf{dephasing time}\footnote{Again, this value also goes by the following names: phase coherence time, phase damping, spin-spin relaxation time, transverse coherence time, and elastic scattering time.}
This time, instead of watching for the the bit flip from $\ket{1}$ to $\ket{0}$ we will watch for a phase flip from $\ket{+}$ to $\ket{-}$ via the following procedure.
\begin{enumerate}
    \item Prepare the state $\ket{0}$
    \item Apply a Hadamard $H$ gate to obtain $\ket{+}$
    \item Wait some time $t$ (during this time a phase might appear on either qubit)
    \item Apply another Hadamard $H$
    \item Measure the qubit
\end{enumerate}
Again, this experiment models an exponential decay with lifetime which we denote $T_2$.
This decoherence time is a measure of how quickly a superposition ($\ket{+}$) will decay into a classical mixture.
Since $T_1$ is a measure of how robust the qubit is against bit flips, and $T_2$ is a measure of how robust the qubit is against becoming probabilistic, these two quantities are very important track the progress of quantum computers.

\subsubsection{Gate Duration}

As qubits are finnicky beasts that don't want to retain their quantum-ness, how quickly we can perform gates is a very important measure and one tracked across many quantum computers.
This measure usually comes under the guise of \ac{CLOPS} first introduced in~\cite{clops}.

\subsubsection{Quantum Volume}

Now that we have seen how one might go about calibrating gates for a quantum computer, we must then ask: does individually calibrated gates imply a fully functional quantum computer?
Researchers have found that despite isolating qubits to the best of their ability, when sending instructions to a qubit (\eg{} a gate), nearby qubits can ``hear'' such a message and be affected by it~\cite{crosstalk,crosstalk2}.\todo{Are there other types of errors that make quantum volume worthwhile?}
With the introduction of errors that are not solely from a single qubit or gate, it makes sense to have a measure of how effective the quantum computer is as a whole.
\citeauthor{qvolume} introduce the notion of \textbf{quantum volume} designed to give a single number to measure the effectiveness of \ac{NISQ}-era quantum computers~\cite{qvolume}.
While understanding the full method to compute a quantum computer's quantum volume, the process consists of applying round of permutations $\pi$ of the qubits, followed by random elements of $\SU{4}$ as seen in~\cref{fig:qvolume}.

\begin{figure}[ht]
    \centering
    \begin{quantikz}
        & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round 1} & \gate[wires=2]{\SU{4}} & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round 2} & \gate[wires=2]{\SU{4}} & \ \ldots\ \qw & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round $d$} & \gate[wires=2]{\SU{4}} & \qw \\
        &                     &                        &                     &                        & \ \ldots\ \qw &                     &                        & \qw \\
        &                     & \gate[wires=2]{\SU{4}} &                     & \gate[wires=2]{\SU{4}} & \ \ldots\ \qw &                     & \gate[wires=2]{\SU{4}} & \qw \\
        &                     &                        &                     &                        & \ \ldots\ \qw &                     &                        & \qw
    \end{quantikz}
    \caption{Quantum Volume Protocol}\label{fig:qvolume}
\end{figure}

\section{Errors}

Errors are ubiquitous in quantum computing and for the near future there is almost certainly no getting around them.
Not only are errors abundant, but they can vary across the chip, and they can very in type.
The first error that is often encountered is that of \textbf{gate errors}.
Some examples of gate errors might be
\begin{itemize}
    \item performing $R_X(\theta + \varepsilon)$ when you intended to do $R_X(\theta)$, or
    \item performing $H + \varepsilon X$ when you intended to apply $H$.
\end{itemize}
This first type of error is sometimes mitigated experimentally if $\varepsilon$ is either fixed, or coupled in some way to $\theta$.
However it may be the case that a more complex coupling is taking place dependent on the surrounding state of the qubit that the gate is acting on.
Since we represent a quantum chip as a graph, one way to quantify errors is to attach a number to each node and edge.
The node error rate represents the computers error rate on performing a single qubit unitary, and the edge represents the computers error rate for performing a 2-qubit unitary.

The next type of error that's important for circuit compilation is that of \textbf{\ac{SPAM}} errors. % TODO it's bolding the acro :(
Again each node on the computers chip can be assigned another number which denotes the computers error rate when performing a measurement.\todo{how to state prep. errors come into play?}

Finally we have cross-talk.\todo{can we even mitigate cross-talk with compilation?}
