%************************************************
\chapter{Quantum Hardware}\label{ch:hardware}
%************************************************

The goal of this chapter is twofold.
First we introduce the most common constraints seen in modern quantum hardware, as well as other common tools used to measure the effectiveness and efficacy of a given quantum computer.
Second we will introduce the mathematical formalism needed in order to formulate the problems related to quantum circuit compilation we will see in~\cref{ch:circuit-compilers}.

\section{Requirements}
As we saw in~\cref{sec:history} the first realization of a qubit happened in~\citeyear{firstqubit}.
A year later theoretical physicist David DiVincenzo published~\cite{divincenzo} where he outlined 5 requirements to make an effective quantum information processing device.
\begin{requirements}
    \item A scalable physical system with well characterized qubits.\label{req:scalable}
    \item The ability to initialize the state of the qubits to a simple fiducial state, such as $\ket{0}^{\otimes n}$.\label{req:initialize}
    \item Long, relevant decoherence times, much longer than the gate operation time.\label{req:Ttimes}
    \item A universal set of quantum gates.\label{req:universal}
    \item A qubit specific measurement capability.\label{req:measure}
\end{requirements}
While not an entirely revolutionary list at the time of writing,\todo{whose writing?} having concrete goals and checkpoints for the community to rally around/focus on meant maintainable, and trackable progress.
Again at the time of writing,~\cref{req:initialize,req:universal,req:measure} have mostly been taken care of and~\cref{req:Ttimes,req:scalable} are the areas we need the most improvement.

\section{Quantum Chips}

\begin{definition}
    A \emph{quantum chip's topology} is a graph $G = (V, E)$ with the vertices representing qubits, and edges representing connections between qubits where quantum gates of the correct arity can be applied.
\end{definition}

As an example take the the topology of IBM's \texttt{ibmq\_jakarta} shown in~\ref{fig:ibm-jakarta}~\cite{ibmq}.
``3'' being connected to ``1'' means that we can apply a 2-qubit unitary targeting both of those qubits, however the hardware does not support native 2-qubit gates between qubits ``2'' and ``6''.
\begin{figure}[ht]
    \centering
    \includestandalone[width=0.4\textwidth]{tikz/jakarta}
    \caption{IBMQ Jakarta Architecture}\label{fig:ibm-jakarta}
\end{figure}

We can now define the main problem of quantum circuit compilation: that of the qubit mapping problem.\footnote{This sometimes also goes by the name of the qubit routing problem, or qubit scheduling problem although sometimes these mean slightly different things.}
If we have both a quantum circuit $C\in G^*$, and a quantum computer with network topology $G$, can the computer perform our circuit?
In order to address this question we must first talk about universal gate sets.

% In \cite{optimalSyn}

\subsection{Hardware Specifications}

\subsubsection{Relaxation and Dephasing Times}\label{sec:Ttimes}

As qubits are two-state systems, they are often implemented experimentally using some physical system (\eg{} an atom) that has a ground state, and an excited state.
Excited states often have a tendency to ``decay'' into ground states, especially so when interacting with the environment.
Hence we define the \textbf{relaxation time}\footnote{This value also goes by the following names: coherence time, amplitude damping, longitudinal coherence time, spin lattice time, and spontaneous emission time.} $T_1$ as the lifetime for the state $\ket{1}$ decaying into $\ket{0}$.
This value can be experimentally found using the following methodology.
\begin{enumerate}
    \item Prepare the state $\ket{0}$
    \item Apply a Pauli $X$ gate to obtain $\ket{1}$
    \item Wait some time $t$ (during this time the qubit may decay into $\ket{0}$)
    \item Measure the qubit
\end{enumerate}
Each time we measure the qubit in the ground state we record the amount of time $t$ we waited.
This process is then modelled with an exponential decay of the form $\e^{-t/T_1}$.

The second important factor we need to understand is the \textbf{dephasing time}\footnote{Again, this value also goes by the following names: phase coherence time, phase damping, spin-spin relaxation time, transverse coherence time, and elastic scattering time.}
This time, instead of watching for the the bit flip from $\ket{1}$ to $\ket{0}$ we will watch for a phase flip from $\ket{+}$ to $\ket{-}$ via the following procedure.
\begin{enumerate}
    \item Prepare the state $\ket{0}$
    \item Apply a Hadamard $H$ gate to obtain $\ket{+}$
    \item Wait some time $t$ (during this time a phase might appear on either qubit)
    \item Apply another Hadamard $H$
    \item Measure the qubit
\end{enumerate}
Again, this experiment models an exponential decay with lifetime which we denote $T_2$.
This decoherence time is a measure of how quickly a superposition ($\ket{+}$) will decay into a classical mixture.
Since $T_1$ is a measure of how robust the qubit is against bit flips, and $T_2$ is a measure of how robust the qubit is against becoming probabilistic, these two quantities are very important track the progress of quantum computers.

\subsubsection{Gate Duration}

As qubits are finnicky beasts that don't want to retain their quantum-ness, how quickly we can perform gates is a very important measure and one tracked across many quantum computers.
This measure usually comes under the guise of \ac{CLOPS} first introduced in~\cite{clops}.

\subsubsection{Quantum Volume}

Now that we have seen how one might go about calibrating gates for a quantum computer, we must then ask: does individually calibrated gates imply a fully functional quantum computer?
Researchers have found that despite isolating qubits to the best of their ability, when sending instructions to a qubit (\eg{} a gate), nearby qubits can ``hear'' such a message and be affected by it~\cite{crosstalk,crosstalk2}.\todo{Are there other types of errors that make quantum volume worthwhile?}
With the introduction of errors that are not solely from a single qubit or gate, it makes sense to have a measure of how effective the quantum computer is as a whole.
\citeauthor{qvolume} introduce the notion of \textbf{quantum volume} designed to give a single number to measure the effectiveness of \ac{NISQ}-era quantum computers~\cite{qvolume}.
While understanding the full method to compute a quantum computer's quantum volume, the process consists of applying round of permutations $\pi$ of the qubits, followed by random elements of $\SU{4}$ as seen in~\cref{fig:qvolume}.

\begin{figure}[ht]
    \centering
    \begin{quantikz}
        & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round 1} & \gate[wires=2]{\SU{4}} & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round 2} & \gate[wires=2]{\SU{4}} & \ \ldots\ \qw & \gate[wires=4]{\pi}\gategroup[4,steps=2,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt}, background]{Round $d$} & \gate[wires=2]{\SU{4}} & \qw \\
        &                     &                        &                     &                        & \ \ldots\ \qw &                     &                        & \qw \\
        &                     & \gate[wires=2]{\SU{4}} &                     & \gate[wires=2]{\SU{4}} & \ \ldots\ \qw &                     & \gate[wires=2]{\SU{4}} & \qw \\
        &                     &                        &                     &                        & \ \ldots\ \qw &                     &                        & \qw
    \end{quantikz}
    \caption{Quantum Volume Protocol}\label{fig:qvolume}
\end{figure}



\section{Errors}

Errors are ubiquitous in quantum computing and for the near future there is almost certainly no getting around them.
Not only are errors abundant, but they can vary across the chip, and they can very in type.
The first error that is often encountered is that of \textbf{gate errors}.
Some examples of gate errors might be
\begin{itemize}
    \item performing $R_X(\theta + \varepsilon)$ when you intended to do $R_X(\theta)$, or
    \item performing $H + \varepsilon X$ when you intended to apply $H$.
\end{itemize}
This first type of error is sometimes mitigated experimentally if $\varepsilon$ is either fixed, or coupled in some way to $\theta$.
However it may be the case that a more complex coupling is taking place dependent on the surrounding state of the qubit that the gate is acting on.
Since we represent a quantum chip as a graph, one way to quantify errors is to attach a number to each node and edge.
The node error rate represents the computers error rate on performing a single qubit unitary, and the edge represents the computers error rate for performing a 2-qubit unitary.

The next type of error that's important for circuit compilation is that of \textbf{\ac{SPAM}} errors. % TODO it's bolding the acro :(
Again each node on the computers chip can be assigned another number which denotes the computers error rate when performing a measurement.\todo{how to state prep. errors come into play?}

Finally we have cross-talk.\todo{can we even mitigate cross-talk with compilation?}
