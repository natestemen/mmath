%*****************************************
\chapter{Quantum Computation}\label{ch:computation}
%*****************************************

In this chapter we will lay the groundwork for the necessary ideas from quantum computation.
We will not attempt to introduce quantum computation from the ground up, but instead introduce and emphasize some ideas we will focus on first.
The notation used here will mostly follow~\cite{watroustqi} and we recommend~\cite{nielsenchuang} for a more thorough introduction to the material.

\section{Historical Development}\label{sec:history}
Without a precise definition of quantum computing it's hard to give a precise storyline through the subject.
However, ideas rarely have clear cut boundaries and we must push forward to understand our messy world regardless.

One of the core tenets of quantum theory is that, at this scale, nature is reversible.
Hence when physicist Charles H. Bennett began investigating reversible Turing machines in~\cite{reversibleturing} we might say the field of quantum computing was \emph{just} beginning to start.
Since Turing machines are the mathematical and theoretical foundation for modern computers, it makes sense that a reversible Turing machine might lay the groundwork as the foundation for a computer that operators under quantum mechanical law.
More than 6 years later, Paul Benioff extended this work to describe a fully quantum mechanical version of a Turing machine in his paper \citetitle{quantumturing}~\cite{quantumturing}.

Once the theoretical foundation had been laid by Bennett and Benioff, Richard Feynman brought the idea mainstream when he proposed using these new computers to simulate quantum mechanics itself.
This idea was very attractive at the time (1981) since our classical computers were not powerful enough to simulate large quantum systems,\footnote{In fact, they still aren't!} and since Feynman was such a popular figure the idea finally took hold.
Feynman motivated the need for a new paradigm in computing as such:
\begin{quote}
    Nature isn't classical, dammit, and if you want to make a simulation of nature, you'd better make it quantum mechanical, and by golly it's a wonderful problem, because it doesn't look so easy.\attrib{Richard P. Feynman in~\cite{feynmansimulator}}
\end{quote}

Even with one of the most famous physicists popularizing the idea, it took another 10 years to see the next major development which came in~\cite{deutch-jozsa-algo} where David Deutsch and Richard Jozsa gave an example of a problem that is solved exponentially faster on a quantum computer than a classical one.
If there was any hesitancy from the academic community at this point about the theoretical usefulness of a quantum computer, this result showed real potential for the emerging technology.
More applications start rolling in with quantum teleportation~\cite{quantumteleportation} and famously Peter Shor's polynomial time algorithm to factor integers (and hence break many modern cryptosystems)~\cite{shor-encryption}.

The latter caught the eye of the US Government and within the year of Shor's publication the \ac{NIST} organized the first government funded conference on quantum computation.\footnote{It's likely this is when quantum computation was put on the radar of the US government. In 2014 leaked documents showed the National Security Agency had begun a project dubbed ``Owning The Net'' whose purpose was to use a quantum computer to break internet cryptography and to ``gain access to and securely return high value target communications''. The status of the project---which also goes under the moniker ``Penetrating Hard Targets''---is unknown.}
There have been many major milestones since this, but perhaps most important to note is the first experimental realization of a qubit happened in 1999 by Yasunobu Nakamura and Jaw-Shen Tsai~\cite{firstqubit}.
Hence it was less than 20 years from when Feynman demonstrated the potential usefulness of a quantum computer to the first experimental realization of the idea.

Since then ambitions have risen and technological progress has allowed for more and more qubits and quantum computers today have even been shown to complete tasks that classical ones cannot in any feasible amount of time.
In particular a team at China's Hefei National Laboratory used their 66-qubit computer\footnote{Affectionately named Zuchongzhi after Chinese mathematican Zu Chongzhi whose computation of $\pi$ was more accurate than any other for more than 800 years.} to complete a task in 4 hours that would take the most performant classical computers tens of thousands of years~\cite{zuchongzhi}.

More recently John Preskill has coined the term \ac{NISQ} as a characterization of the quantum computers that have dominated the past decade, and will likely continue to for the next few years~\cite{nisq}.
He takes these to be computers with 50-100 qubits for which noise will be a major factor in deciding what quantum circuits we can and cannot run.
The problem presented in this document is relevant to quantum computers past the \ac{NISQ}-era, but are especially important as we attempt to squeeze every ounce of computation out of them.

% TODO conclusion

\section{Quantum Computation}

In this section we will go over the basics of quantum computation.
This section is written with a moderate amount of protest since I do not believe I will give a pedagogically proper and sound treatment of the material.
Before continuing I would like to recommend~\cite{nielsenchuang} as well as \url{https://quantum.country} as great resources to learn the basics of quantum computing.

\subsection{Formalism}

A quantum bit, or \textbf{qubit} for short, is a vector $\ket{\psi}$ in 2-dimensional complex space $\C^2$ such that $\norm{\ket{\psi}} = 1$.
Often the following canonical basis is chosen and referred to as the computational basis.
\begin{align}
    \ket{0} \defeq \mqty[1 \\ 0] & & \ket{1} \defeq \mqty[0 \\ 1]
\end{align}
In this basis a qubit is a vector
\begin{equation}\label{eq:qubit}
    \ket{\psi} = \alpha\ket{0} + \beta\ket{1} = \mqty[\alpha \\ \beta]
\end{equation}
with the normalization condition that $\abs{\alpha}^2 + \abs{\beta}^2 = 1$.
In the case of \cref{eq:qubit} the state $\ket{\psi}$ is said to be in a \textbf{superposition} of state $\ket{0}$ and $\ket{1}$.

We often need to understand more complicated systems than just simple qubits, and to do so we use the \textbf{tensor product} to build up systems from subsystems.
\Eg{} if $\ket{\psi}\in\C^2$ and $\ket{\phi}\in\C^2$ represent two distinct physical qubits, we can represent the combined system as a single vector $\ket{\psi}\otimes \ket{\phi}$ in a larger complex Euclidean space $\C^2\otimes \C^2\cong \C^4$.
In the computational basis we can expand this as
\begin{align}
    \ket{\psi}\otimes \ket{\phi} & = \qty(\alpha\ket{0} + \beta\ket{1})\otimes\qty(\gamma\ket{0} + \delta\ket{1})                                                                \\
                                 & = \alpha\gamma\ket{0}\otimes\ket{0} + \alpha\delta\ket{0}\otimes\ket{1} + \beta\gamma\ket{1}\otimes\ket{0} + \beta\delta\ket{1}\otimes\ket{1}
\end{align}
where $\alpha, \beta, \gamma, \delta \in \C$.

With the objects of the theory defined, we must now understand the dynamics, or choreography of the theory.
As stated in~\cref{sec:history}, we take the theory of quantum mechanics to be reversible, and hence any operation we perform on a qubit $\ket{\psi}$ must be undo-able.
Thankfully linear algebra has just the tool to transform complex vectors in a reversible, and general way: unitary matrices!
\begin{definition}
    An $n\times n$ matrix $A$ is called \emph{unitary} if
    \begin{equation}\label{eq:unitary}
        AA^\dagger = A^\dagger A = \1
    \end{equation}
    where $^\dagger$ is the conjugate transpose.
    The collection of unitary matrices of dimension $n$ is called the \emph{unitary group} and is denoted \gls{un}.
\end{definition}
Hence when we have a qubit $\ket{\psi}$ and perform some action on it, we then have a new state $\ket{\phi} = U\ket{\psi}$ where $U$ represents whatever action we performed.
The condition shown in~\cref{eq:unitary} is quite restrictive: where a general $n \times n$ matrix has $2n^2$ real degrees of freedom, an element of $\U{n}$ only has $n^2$.\footnote{This is to say $\dim_\R\U{n} = n^2$.}
In fact for a general element of $\U{2}$ we can decompose it into pieces that look much more familiar.
\begin{example}
    Let $A$ be an arbitrary element of $\U{2}$.
    Then the following decomposition holds for $\alpha, \beta, \gamma, \delta \in \R$.
    \begin{equation}
        A = \e^{\iu\alpha}\mqty[\dmat[0]{\e^{-\iu \beta}, \e^{\iu \beta}}]\mqty[\cos\gamma & -\sin\gamma \\ \sin\gamma & \phantom{+}\cos\gamma]\mqty[\dmat[0]{\e^{-\iu \delta}, \e^{\iu \delta}}]
    \end{equation}
    As we can see the middle matrix is simply a 2D rotation matrix, and the other two are of a simple diagonal form.
    Lastly we have the global phase $\e^{\iu \alpha}$.
\end{example}

This is a particularly important example as the idea of decomposing unitary matrices into simpler pieces is something we will need heavily in circuit compilation tasks.

\subsection{Quantum Gates}
A quantum gate is simply any unitary.
In this document we will mainly discuss quantum gates acting on 1 to 3 qubits since that is the range most quantum algorithms make use.
Most physical quantum computers today can perform single and double qubit gates.
\begin{table}[ht]
    \centering
    % \begin{noindent}
    \begin{tabular}{cccc}
        Name           & Notation & Circuit Diagram                                                                                 & Matrix                                                 \\ \toprule
        Pauli X        & $X$      & \begin{tikzcd} \qw & \gate{X} & \qw \end{tikzcd}                                                & $\smqty[0 & 1 \\ 1 & 0]$                               \\
        Pauli Z        & $Z$      & \begin{tikzcd} \qw & \gate{Z} & \qw \end{tikzcd}                                                & $\smqty[1 & \phantom{-}0 \\ 0 & -1]$                   \\
        Hadamard       & $H$      & \begin{tikzcd} \qw & \gate{H} & \qw \end{tikzcd}                                                & $\frac{1}{\sqrt{2}}\smqty[1 & \phantom{-}1 \\ 1 & -1]$ \\
        Controlled Not & \CNOT    & \begin{tikzcd} \qw & \ctrl{1} & \qw \\ \qw & \targ{} & \qw \end{tikzcd}                         & $\smqty[1 & & & \\ & 1 & & \\ & & 0 & 1 \\ & & 1 & 0]$ \\
        Toffoli        & \CCNOT   & \begin{tikzcd} \qw & \ctrl{1} & \qw \\ \qw & \ctrl{1} & \qw \\ \qw & \targ{} & \qw \end{tikzcd} & $\smqty[1 & & & & & & & \\ & 1 & & & & & & \\ & & 1 & & & & & \\ & & & 1 & & & & \\ & & & & 1 & & & \\ & & & & & 1 & & \\ & & & & & & 0 & 1 \\ & & & & & & 1 & 0]$
    \end{tabular}
    % \end{noindent}
    \caption{Common Quantum Gates}\label{tab:commongates}
\end{table}


\begin{example}
    As we will later see, it is often important to be able to move qubits around on a physical chip.
    To do this we cannot physically move them, but rather apply some sort of combination of gates enact the swap.
    Thus we are looking for a unitary operation $\SWAP: \C^2\otimes \C^2 \to \C^2\otimes \C^2$ that acts as $\SWAP\qty[\ket{\psi}\otimes\ket{\phi}] = \ket{\phi}\otimes\ket{\psi}$.
    This is can be done using \CNOT{} gates and is shown diagrammatically.
    \begin{equation}\label{eq:cnotswap}
        \begin{quantikz}
            & \ctrl{1} & \targ{}   & \ctrl{1} & \midstick[2,brackets=none]{$\eqdef$} \qw & \swap{1} & \midstick[2,brackets=none]{$\equiv$} \qw & \gate[swap]{} & \qw \\
            & \targ{}  & \ctrl{-1} & \targ{}  & \qw                               & \targX{} & \qw                               &               & \qw
        \end{quantikz}
    \end{equation}
    Where the first equality shows us how to perform the swap with 3 \CNOT{} gates, and the last equality is an equivalence of notation.

    We can also show this using more mathematical notation if we understand the \CNOT{} map to act as $\CNOT\qty[\ket{x}\otimes\ket{y}] = \ket{x}\ket{x\oplus y}$ where $x, y \in \F$ and $\oplus$ is binary addition.
    With this we can explicitly compute the action of this circuit.
    Here we use the notation $\CNOT^a_b$ to mean a $\CNOT{}$ gate acting from qubit $a$ (the control qubit) to qubit $b$ (the target qubit).
    Then the 3 \CNOT{} gates in~\cref{eq:cnotswap} act under the following manipulations.
    \begin{align*}
        \ket{x}\otimes\ket{y} & \xrightarrow{\CNOT^1_2} \ket{x}\otimes\ket{x\oplus y}                                                     \\
                              & \xrightarrow{\CNOT^2_1} \ket{x\oplus (x\oplus y)}\otimes \ket{x\oplus y}  = \ket{y}\otimes\ket{x\oplus y} \\
                              & \xrightarrow{\CNOT^1_2} \ket{y}\otimes\ket{(x\oplus y)\oplus y} = \ket{y}\otimes \ket{x}.
    \end{align*}
    Thus exactly as desired.
\end{example}

\subsection{Quantum Circuits}

We are now ready to start putting these pieces together to build larger structures.
Since it is common that a quantum computer can perform a multitude of gates, we collect these together to form a \textbf{quantum gate set}.
These are the gates that we will be able to natively perform on our hardware.
\begin{definition}
    A \emph{quantum gate set} is a (typically finite) subset $G \subseteq \U{2^n}$. An element of $G$ is called a quantum gate.
\end{definition}
From these gates, we can construct a \textbf{quantum circuit} by applying a sequence of elements from the gate set.
\begin{definition}
    Let $G$ be a quantum gate set, and let \gls{kleene} denote\footnote{This operation is known as the Kleene star.} the set of finite length words over $G$.
    A \emph{quantum circuit} is an element of $G^*$.
\end{definition}
Thus if our gate set $G = \qty{a, b, c}$, then some example circuits may be $aacba$, $cccbbb$, $cbbbab$, $ab$.
ugh


\section{Quantum Circuits}
There are three main models used for quantum computation:
\begin{itemize}
    \item circuital quantum computing
    \item adiabatic quantum computing
    \item measurement based quantum computing
\end{itemize}
Because of the ease in implementing universal quantum computation, the circuital model has become the most popular. % TODO
In this model we represent programs diagrammatically.
\begin{figure}[ht]
    \centering
    \begin{quantikz}
        & \gate{U_0} & \ctrl{1} & \gate{U_1} & \ctrl{1}            & \swap{2} & \gate[wires=3]{U_3} & \qw \\
        & \gate{U_0} & \targ{}  & \octrl{-1} & \gate[wires=2]{U_2} & \qw      &                     & \qw \\
        & \gate{U_0} & \qw      & \qw        &                     & \targX{} &                     & \qw
    \end{quantikz}
    \caption{Example Quantum Circuit}\label{fig:excircuit}
\end{figure}
The theoretical laws of quantum mechanics tell us that time evolution is governed by unitary operators.
Hence in theoretical developments of quantum circuits we

\section{Formalizing}

This formalization is inspired by~\cite{formalcircuit}.
% The first important object to define is that of a \textbf{quantum gate set}.
% These are the gates that we will be able to natively perform on our hardware.
% \begin{definition}
%     A \emph{quantum gate set} is a (typically finite) subset $G\subseteq \U{2^n}$. An element of $G$ is called a quantum gate.
% \end{definition}
% From these gates, we can construct a \textbf{quantum circuit} by applying a sequence of elements from the gate set.
% \begin{definition}
%     Let $G$ be a quantum gate set, and let $G^*$ denote\footnote{This operation is known as the Kleene star.} the set of words over $G$.
%     A \emph{quantum circuit} is an element of $G^*$.
% \end{definition}
% Thus if our gate set $G = \qty{a, b, c}$, then some example circuits may be $aacba$, $cccbbb$, $cbbcbab$.

Something to note here is that in this abstraction, all of our quantum gates are assumed to act on all qubits.
Hence if we have hardware with 2 qubits, and we can perform a Pauli $X$ gate on either qubit, then our gate is not simply $\qty{X}$, but rather $\qty{\1\otimes \1, \1\otimes X, X\otimes \1, X\otimes X}$.\footnote{We don't always think of the identity gate $\1$ as a gate that needs to be included, but doing nothing to a qubit is no easy task, so it's important to remember to treat it just like any other gate and understand it's error rates as well.}
Sometimes this gate set is denoted $\qty{\1, X_0, X_1, X_0X_1}$, but we will try and be explicit here.

We can now define a map $\mult: G^* \to \U{2^n}$ which takes a quantum circuit, or sequence of gates, and multiplies them together to get a final unitary: $\mult(U_1U_2\cdots U_n) = U_1\cdot U_2\cdots U_n$.
This map allows us to frame the following important question.

\begin{question}\label{qu:synthesis}
    Given a quantum gate set $G$, and unitary $U\in\U{2^n}$, does there exist a circuit $C\in G^*$, such that $\mult(C) = U$?
\end{question}
In the case this can we done, we say that a circuit $C$ implements a unitary $U$.
Further, if the answer to~\ref{qu:synthesis} is positive, there is often a follow on question.
\begin{question}\label{qu:optimalsynthesis}
    If $\mult(C) = U$, and $f: G^* \to \R$ is a cost function, can we find
    \begin{equation*}
        C_\text{min} = \argmin_{C\in G^*} \qty{f(C) : \mult(C) = U}?
    \end{equation*}
\end{question}
Some examples of common cost functions are given below, and multiple can be used in the case of tie-breaking.
\begin{itemize}
    \item $f(C) = \mathtt{length}(C)$ (commonly referred to as the depth of the circuit)
    \item $f(C) = $ \# of uses of a particular gate in $C$
    \item $f(C) = \mathtt{duration}(C)$ (by this we mean the total elapsed time the circuit takes)
\end{itemize}

\begin{definition}
    A \emph{quantum chip's topology} is a graph $G = (V, E)$ with the vertices representing qubits, and edges representing connections between qubits where quantum gates of the correct arity can be applied.
\end{definition}

As an example take the the topology of IBM's \texttt{ibmq\_jakarta} shown in~\ref{fig:ibm-jakarta}.
``3'' being connected to ``1'' means that we can apply a 2-qubit unitary targeting both of those qubits, however the hardware does not support native 2-qubit gates between qubits ``2'' and ``6''.
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}
        \tikzset{
            node/.style={
                    very thick,
                    circle,
                    fill=blue!20,
                    draw,
                    minimum size=.8cm,
                }
        }
        \node[node] (0) {$0$};
        \node[node] (1) [right = .8cm of 0] {$1$};
        \node[node] (2) [right = .8cm of 1] {$2$};
        \node[node] (3) [below = .8cm of 1] {$3$};
        \node[node] (5) [below = .8cm of 3] {$5$};
        \node[node] (4) [left  = .8cm of 5] {$4$};
        \node[node] (6) [right = .8cm of 5] {$6$};

        \path[draw, very thick]
        (0) edge node {} (1)
        (1) edge node {} (2)
        (1) edge node {} (3)
        (3) edge node {} (5)
        (5) edge node {} (4)
        (5) edge node {} (6);
    \end{tikzpicture}
    \caption{IBMQ Jakarta Architecture}\label{fig:ibm-jakarta}
\end{figure}

We can now define the main problem of quantum circuit compilation: that of the qubit mapping problem.\footnote{This sometimes also goes by the name of the qubit routing problem, or qubit scheduling problem although sometimes these mean slightly different things.}
If we have both a quantum circuit $C\in G^*$, and a quantum computer with network topology $G$, can the computer perform our circuit?
In order to address this question we must first talk about universal gate sets.

\subsection{Universal Gate Sets}
In order to harness the full power of a quantum computer, we hope it to be able
\begin{definition}
    A gate set $G$ on $n$ qubits is called \emph{universal} if for all $U\in\U{2^n}$ there exists a circuit $C\in G^*$ such that $\mult(C) = U$.
\end{definition}

The question of which gate sets are universal for quantum computation is important both for our theoretical understanding of quantum computation, but also for building physical devices.
Examples that have been shown to be universal are
\begin{itemize}
    \item \CNOT{} plus $\U{2}$ as shown in~\cite{universal-cnot-u2}
    \item \CNOT{}, Hadamard, and the $\frac{\pi}{8}$-gate\footnote{The $\frac{\pi}{8}$-gate is also sometimes called $T$ and has matrix representation $\smqty[1 & 0 \\ 0 & \e^{\iu\pi/4}]$.} as shown in~\cite{universal-cnot-had-p8}
    \item \CCNOT{} (Toffoli), Hadamard, and the $\frac{\pi}{4}$-gate\footnote{The $\frac{\pi}{4}$-gate is also sometimes called $S$ and has matrix representation $\smqty[1 & 0 \\ 0 & \e^{\iu\pi/2}]$.} as shown in~\cite{universal-ccnot-had-p4}
    \item \CNOT{} plus any single qubit gate that does not preserve the computational basis and is not the Hadamard gate as shown in~\cite{universal-cnot-basis-change}
\end{itemize}

The authors in~\cite{universal-cnot-u2} also show

With these universal gate sets


% With these two definitions we can already formulate a very important question.
% Suppose we have a target unitary $U\in\U{2^n}$.
% Is there a circuit $C\in\free{G}$ such that $\dbrackets{C} = U$?
% hi
% If we'd like our circuit to implement a target unitary $U\in\U{2^n}$,
% In \cite{optimalSyn}